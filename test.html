<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
</head>

<body>
	<script>
		function rot(index, modulo) {
			return (modulo + (index % modulo)) % modulo;
		}

		const colorRegistry = [
			'#FFB000',
			'#DC267F',
			'#994F00',
			'#40B0A6',
			'#B66DFF',
		];

		const deepClone = _.cloneDeep;

		const SWIMLANE_HEIGHT = 22;
		const SWIMLANE_WIDTH = 11;
		const SWIMLANE_CURVE_RADIUS = 5;
		const CIRCLE_RADIUS = 4;
		const CIRCLE_STROKE_WIDTH = 2;

		function asCssVariableName(colorIdent) {
			return `--vscode-${colorIdent.replace(/\./g, '-')}`;
		}

		function asCssVariable(color) {
			return `var(${asCssVariableName(color)})`;
		}

		function findLastIndex(nodes, id) {
			for (let i = nodes.length - 1; i >= 0; i--) {
				if (nodes[i].id === id) {
					return i;
				}
			}

			return -1;
		}

	</script>
	<script>

		function createPath(colorIdentifier) {
			const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			path.setAttribute('fill', 'none');
			path.setAttribute('stroke-width', '1px');
			path.setAttribute('stroke-linecap', 'round');
			path.style.stroke = colorIdentifier;

			return path;
		}

		function drawCircle(index, radius, strokeWidth, colorIdentifier) {
			const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			circle.setAttribute('cx', `${SWIMLANE_WIDTH * (index + 1)}`);
			circle.setAttribute('cy', `${SWIMLANE_WIDTH}`);
			circle.setAttribute('r', `${radius}`);

			circle.style.strokeWidth = `${strokeWidth}px`;
			if (colorIdentifier) {
				circle.style.fill = colorIdentifier;
			}

			return circle;
		}


		function drawVerticalLine(x1, y1, y2, color) {
			const path = createPath(color);
			path.setAttribute('d', `M ${x1} ${y1} V ${y2}`);

			return path;
		}

		function getLabelColorIdentifier(historyItem, colorMap) {
			for (const ref of historyItem.references ?? []) {
				const colorIdentifier = colorMap.get(ref.id);
				if (colorIdentifier !== undefined) {
					return colorIdentifier;
				}
			}

			return undefined;
		}

		function toISCMHistoryItemViewModelArray(
			historyItems,
			colorMap = new Map(),
			currentHistoryItemRef,
			currentHistoryItemRemoteRef,
			currentHistoryItemBaseRef
		) {
			let colorIndex = -1;
			const viewModels = [];

			for (let index = 0; index < historyItems.length; index++) {
				const historyItem = historyItems[index];

				const isCurrent = historyItem.id === currentHistoryItemRef?.revision;
				const outputSwimlanesFromPreviousItem = viewModels.at(-1)?.outputSwimlanes ?? [];
				const inputSwimlanes = outputSwimlanesFromPreviousItem.map(i => deepClone(i));
				const outputSwimlanes = [];

				let firstParentAdded = false;

				// Add first parent to the output
				if (historyItem.parentIds.length > 0) {
					for (const node of inputSwimlanes) {
						if (node.id === historyItem.id) {
							if (!firstParentAdded) {
								outputSwimlanes.push({
									id: historyItem.parentIds[0],
									color: getLabelColorIdentifier(historyItem, colorMap) ?? node.color
								});
								firstParentAdded = true;
							}

							continue;
						}

						outputSwimlanes.push(deepClone(node));
					}
				}

				// Add unprocessed parent(s) to the output
				for (let i = firstParentAdded ? 1 : 0; i < historyItem.parentIds.length; i++) {
					// Color index (label -> next color)
					let colorIdentifier

					if (i === 0) {
						colorIdentifier = getLabelColorIdentifier(historyItem, colorMap);
					} else {
						const historyItemParent = historyItems
							.find(h => h.id === historyItem.parentIds[i]);
						colorIdentifier = historyItemParent ? getLabelColorIdentifier(historyItemParent, colorMap) : undefined;
					}

					if (!colorIdentifier) {
						colorIndex = rot(colorIndex + 1, colorRegistry.length);
						colorIdentifier = colorRegistry[colorIndex];
					}

					outputSwimlanes.push({
						id: historyItem.parentIds[i],
						color: colorIdentifier
					});
				}

				// Add colors to references
				const references = (historyItem.references ?? [])
					.map(ref => {
						let color = colorMap.get(ref.id);
						if (colorMap.has(ref.id) && color === undefined) {
							// Find the history item in the input swimlanes
							const inputIndex = inputSwimlanes.findIndex(node => node.id === historyItem.id);

							// Circle index - use the input swimlane index if present, otherwise add it to the end
							const circleIndex = inputIndex !== -1 ? inputIndex : inputSwimlanes.length;

							// Circle color - use the output swimlane color if present, otherwise the input swimlane color
							color = circleIndex < outputSwimlanes.length ? outputSwimlanes[circleIndex].color :
								circleIndex < inputSwimlanes.length ? inputSwimlanes[circleIndex].color : historyItemRefColor;
						}

						return { ...ref, color };
					});

				// Sort references
				references.sort((ref1, ref2) =>
					compareHistoryItemRefs(ref1, ref2, currentHistoryItemRef, currentHistoryItemRemoteRef, currentHistoryItemBaseRef));

				viewModels.push({
					historyItem: {
						...historyItem,
						references
					},
					isCurrent,
					inputSwimlanes,
					outputSwimlanes,
				});
			}

			return viewModels;
		}

		function toSCMHistoryItem(id, parentIds, references) {
			return { id, parentIds, subject: '', message: '', references }
		}

		function renderSCMHistoryItemGraph(historyItemViewModel) {
			const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svg.classList.add('graph');

			const historyItem = historyItemViewModel.historyItem;
			const inputSwimlanes = historyItemViewModel.inputSwimlanes;
			const outputSwimlanes = historyItemViewModel.outputSwimlanes;

			// Find the history item in the input swimlanes
			const inputIndex = inputSwimlanes.findIndex(node => node.id === historyItem.id);

			// Circle index - use the input swimlane index if present, otherwise add it to the end
			const circleIndex = inputIndex !== -1 ? inputIndex : inputSwimlanes.length;

			// Circle color - use the output swimlane color if present, otherwise the input swimlane color
			const circleColor = circleIndex < outputSwimlanes.length ? outputSwimlanes[circleIndex].color :
				circleIndex < inputSwimlanes.length ? inputSwimlanes[circleIndex].color : historyItemRefColor;

			let outputSwimlaneIndex = 0;
			for (let index = 0; index < inputSwimlanes.length; index++) {
				const color = inputSwimlanes[index].color;
				console.log(color);

				// Current commit
				if (inputSwimlanes[index].id === historyItem.id) {
					// Base commit
					if (index !== circleIndex) {
						const d = [];
						const path = createPath(color);

						// Draw /
						d.push(`M ${SWIMLANE_WIDTH * (index + 1)} 0`);
						d.push(`A ${SWIMLANE_WIDTH} ${SWIMLANE_WIDTH} 0 0 1 ${SWIMLANE_WIDTH * (index)} ${SWIMLANE_WIDTH}`);

						// Draw -
						d.push(`H ${SWIMLANE_WIDTH * (circleIndex + 1)}`);

						path.setAttribute('d', d.join(' '));
						svg.append(path);
					} else {
						outputSwimlaneIndex++;
					}
				} else {
					// Not the current commit
					if (outputSwimlaneIndex < outputSwimlanes.length &&
						inputSwimlanes[index].id === outputSwimlanes[outputSwimlaneIndex].id) {
						if (index === outputSwimlaneIndex) {
							// Draw |
							const path = drawVerticalLine(SWIMLANE_WIDTH * (index + 1), 0, SWIMLANE_HEIGHT, color);
							svg.append(path);
						} else {
							const d = [];
							const path = createPath(color);

							// Draw |
							d.push(`M ${SWIMLANE_WIDTH * (index + 1)} 0`);
							d.push(`V 6`);

							// Draw /
							d.push(`A ${SWIMLANE_CURVE_RADIUS} ${SWIMLANE_CURVE_RADIUS} 0 0 1 ${(SWIMLANE_WIDTH * (index + 1)) - SWIMLANE_CURVE_RADIUS} ${SWIMLANE_HEIGHT / 2}`);

							// Draw -
							d.push(`H ${(SWIMLANE_WIDTH * (outputSwimlaneIndex + 1)) + SWIMLANE_CURVE_RADIUS}`);

							// Draw /
							d.push(`A ${SWIMLANE_CURVE_RADIUS} ${SWIMLANE_CURVE_RADIUS} 0 0 0 ${SWIMLANE_WIDTH * (outputSwimlaneIndex + 1)} ${(SWIMLANE_HEIGHT / 2) + SWIMLANE_CURVE_RADIUS}`);

							// Draw |
							d.push(`V ${SWIMLANE_HEIGHT}`);

							path.setAttribute('d', d.join(' '));
							svg.append(path);
						}

						outputSwimlaneIndex++;
					}
				}
			}

			// Add remaining parent(s)
			for (let i = 1; i < historyItem.parentIds.length; i++) {
				const parentOutputIndex = findLastIndex(outputSwimlanes, historyItem.parentIds[i]);
				if (parentOutputIndex === -1) {
					continue;
				}

				// Draw -\
				const d = [];
				const path = createPath(outputSwimlanes[parentOutputIndex].color);

				// Draw \
				d.push(`M ${SWIMLANE_WIDTH * parentOutputIndex} ${SWIMLANE_HEIGHT / 2}`);
				d.push(`A ${SWIMLANE_WIDTH} ${SWIMLANE_WIDTH} 0 0 1 ${SWIMLANE_WIDTH * (parentOutputIndex + 1)} ${SWIMLANE_HEIGHT}`);

				// Draw -
				d.push(`M ${SWIMLANE_WIDTH * parentOutputIndex} ${SWIMLANE_HEIGHT / 2}`);
				d.push(`H ${SWIMLANE_WIDTH * (circleIndex + 1)} `);

				path.setAttribute('d', d.join(' '));
				svg.append(path);
			}

			// Draw | to *
			if (inputIndex !== -1) {
				const path = drawVerticalLine(SWIMLANE_WIDTH * (circleIndex + 1), 0, SWIMLANE_HEIGHT / 2, inputSwimlanes[inputIndex].color);
				svg.append(path);
			}

			// Draw | from *
			if (historyItem.parentIds.length > 0) {
				const path = drawVerticalLine(SWIMLANE_WIDTH * (circleIndex + 1), SWIMLANE_HEIGHT / 2, SWIMLANE_HEIGHT, circleColor);
				svg.append(path);
			}

			// Draw *
			if (historyItemViewModel.isCurrent) {
				// HEAD
				const outerCircle = drawCircle(circleIndex, CIRCLE_RADIUS + 3, CIRCLE_STROKE_WIDTH, circleColor);
				svg.append(outerCircle);

				const innerCircle = drawCircle(circleIndex, CIRCLE_STROKE_WIDTH, CIRCLE_RADIUS);
				svg.append(innerCircle);
			} else {
				if (historyItem.parentIds.length > 1) {
					// Multi-parent node
					const circleOuter = drawCircle(circleIndex, CIRCLE_RADIUS + 2, CIRCLE_STROKE_WIDTH, circleColor);
					svg.append(circleOuter);

					const circleInner = drawCircle(circleIndex, CIRCLE_RADIUS - 1, CIRCLE_STROKE_WIDTH, circleColor);
					svg.append(circleInner);
				} else {
					// Node
					const circle = drawCircle(circleIndex, CIRCLE_RADIUS + 1, CIRCLE_STROKE_WIDTH, circleColor);
					svg.append(circle);
				}
			}

			// Set dimensions
			svg.style.height = `${SWIMLANE_HEIGHT}px`;
			svg.style.width = `${SWIMLANE_WIDTH * (Math.max(inputSwimlanes.length, outputSwimlanes.length, 1) + 1)}px`;

			return svg;
		}

		const models = [
			toSCMHistoryItem('a', ['b', 'c']),
			toSCMHistoryItem('c', ['b']),
			toSCMHistoryItem('b', ['d', 'e']),
			toSCMHistoryItem('e', ['f']),
			toSCMHistoryItem('f', ['g']),
			toSCMHistoryItem('d', ['h']),
		];

		const res = toISCMHistoryItemViewModelArray(models)

		console.log(res);


		const svgs = res.map(item => {
			const svg = renderSCMHistoryItemGraph(item);
			return `<div style="height: 22px;line-height="22px">${svg.outerHTML}<span >提交信息</span></div>`;
		});

		const container = document.createElement('div');
		container.innerHTML = svgs.join('');
		document.body.appendChild(container);



	</script>
</body>

</html>
